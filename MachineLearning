{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "9e9fd160",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Done!\n",
      "                                                best  score\n",
      "0  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...    -20\n",
      "1  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...    -20\n",
      "2  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...    -20\n",
      "3  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...    -20\n",
      "4  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...    -20\n",
      "5  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...    -20\n",
      "6  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...    -20\n",
      "7  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...    -20\n",
      "8  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...    -20\n",
      "9  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...    -20\n"
     ]
    }
   ],
   "source": [
    "from numpy.random import randint\n",
    "from numpy.random import rand\n",
    "import pandas as pd\n",
    "\n",
    "def onemax(x):\n",
    "    return -sum(x)\n",
    "\n",
    "def selection(pop, scores, k=3):\n",
    "    selection_1 = randint(len(pop))\n",
    "    for ix in randint(0, len(pop), k-1):\n",
    "        if scores[ix] < scores[selection_1]:\n",
    "            selection_1 = ix\n",
    "    return pop[selection_1]\n",
    "    \n",
    "def crossover(p1, p2, r_cross):\n",
    "    c1, c2 = p1.copy(), p2.copy()\n",
    "    if rand() < r_cross:\n",
    "        pt = randint(1, len(p1)-2)\n",
    "        c1 = p1[:pt] + p2[pt:]\n",
    "        c2 = p2[:pt] + p1[pt:]\n",
    "    return [c1, c2]\n",
    "\n",
    "def mutation(bitstring, r_mut):\n",
    "    for i in range(len(bitstring)):\n",
    "        if rand() < r_mut:\n",
    "            bitstring[i] = 1 - bitstring[i]\n",
    "            \n",
    "def genetic_algorithm(objective, n_bits, n_iter, n_pop, r_cross, r_mut):\n",
    "    pop = [randint(0,2,n_bits).tolist() for _ in range(n_pop)]\n",
    "    best, best_eval = 0, objective(pop[0])\n",
    "    for gen in range(n_iter):\n",
    "        scores = [objective(c) for c in pop]\n",
    "        for i in range(n_pop):\n",
    "            if scores[i] < best_eval:\n",
    "                best, best_eval = pop[i], scores[i]\n",
    "                #print(\">%d, new best f(%s) = %.3f\" % (gen, pop[i], scores[i]))\n",
    "        selected = [selection(pop, scores) for _ in range(n_pop)]\n",
    "        children = list()\n",
    "        for i in range(0, n_pop, 2):\n",
    "            p1, p2 = selected[i], selected[i+1]\n",
    "            for c in crossover(p1, p2, r_cross):\n",
    "                mutation(c, r_mut)\n",
    "                children.append(c)\n",
    "        pop = children\n",
    "    return [best, best_eval]\n",
    "\n",
    "n_iter = 10\n",
    "n_bits = 20\n",
    "n_pop = 100\n",
    "r_cross = 0.9\n",
    "r_mut = 1.0 / float(n_bits)\n",
    "best_list, score_list = [], []\n",
    "for i in range(n_iter):\n",
    "    best, score = genetic_algorithm(onemax, n_bits, n_iter, n_pop, r_cross, r_mut)\n",
    "    best_list.append(best)\n",
    "    score_list.append(score)\n",
    "print('Done!')\n",
    "\n",
    "results = pd.DataFrame({'best':best_list, 'score':score_list})\n",
    "print(results)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2be5950e",
   "metadata": {},
   "source": [
    "#### Genetic Algorithm\n",
    "\n",
    ">> This is similar to the numpy one, and slower than the numpy one, but I used a dataframe as a means of holding the information and displaying it. I rather use NumPy for something of this nature. \n",
    "\n",
    ">The genetic algorthm is a global search optimization algorithm. This is a optimization technique that is based on natural selection, and biological evolution. In this program we establish functions for the selection rules, crossover rules, and mutation rules. Selection rules select the individuals that contribute to the next generation. These individuals are called parents. Crossover rules combine two parents to form children for the next generation. Mutation rules apply random change to individual parents to form children.\n",
    "\n",
    ">I will start by describing the variables. n_iter is the total number of iterations, n_bits is the bits. n_pop is the population size. r_cross is the crossover rate. r_mut is the mutation rate.\n",
    "\n",
    ">In the beginning of the genetic algorithm, we create a random initial population. We then create a sequence of new populations called best, and best_eval. We then create a scores variable that that evaluates the candidates in the population.\n",
    "\n",
    ">This next section involves the functions used to make this genetic algorithm.\n",
    "\n",
    ">A tournament selection procedure is implemented as and it takes the population and returns a selected parent. This can be seen in the selection function. This function is called once for each position in the population to create a list of parents.\n",
    "\n",
    ">We then work to create the next generation by using the crossover function. The crossover function uses a draw of a random number in the range of 0,1 to determine if crossover is performed, and then selects a valid split point if the crossover is to be performed. It's important to note the randomization that is being performed in this step as c1 and c2 are children and p1 and p2 are parents. the pt variable is a random integer between 1 and the length of the parent list. 2 is subtracted so that the crossover point is not at the end of the string. The assignment of the c1 and c2 variables performs the crossover, and these variables are returned so that it completes the crossover function.\n",
    "\n",
    ">We then perform mutation which also includes more randomization. The length of the bitstring acts as the iteratible of the for loop, and the r_mut is the variable of random change. This function effectively flips the bitstring by subtracting 1 from it.\n",
    "\n",
    ">This function then goes onto the next generation by creating a children variable that acts as a list. The population is iterated in increments of 2 to select parent pairs. There is another iteration where the list created by the crossover function is used as an iterable for the mutation function. The end result is stored for the next generation in the children variable. The population is then replaced by the children variable as a means of establishing the new generation.\n",
    "\n",
    ">I used OneMax to test this algorithm, and it takes a bitstring of integer values and returns the negative sum of the values. OneMax is the objective of this test.\n",
    "\n",
    ">I found this optimization algorithm to be the best for the purpose of sentiment analysis as that relates to my project. It's a very accurate algorithm as I found that simulated annealing was too dependent on randomization.\n",
    "\n",
    ">>I held the answer in a dataframe and this can be useful in the instance of expanding the use of the genetic algorithm. You can then examine the paths taken and even develop a reward signal that further optimizes the algorithm."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "7f8b8727",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "   0  1  2\n",
      "0  1  1  1\n",
      "1  0  1  2\n",
      "2  1  5  3\n",
      "[1 1 3]\n",
      "     0    1    2    3\n",
      "0  1.0  0.0  0.0  0.0\n",
      "1  1.0  1.0  0.0  0.0\n",
      "2  1.0  1.0  1.0  0.0\n",
      "3  1.0  1.0  1.0  1.0\n",
      "     0    1    2    3\n",
      "0  1.0  1.0  1.0  1.0\n",
      "1  0.0  1.0  1.0  1.0\n",
      "2  0.0  0.0  1.0  1.0\n",
      "3  0.0  0.0  0.0  1.0\n",
      "0    3.605551\n",
      "dtype: float64\n",
      "0    [0.5547001962252291, 0.8320502943378437]\n",
      "dtype: object\n",
      "0     5.0\n",
      "1    12.0\n",
      "dtype: float64\n",
      "0    1.0\n",
      "1    1.0\n",
      "dtype: float64\n",
      "Enter the dimension of the identity matrix: 4\n",
      "     0    1    2    3\n",
      "0  1.0  0.0  0.0  0.0\n",
      "1  0.0  1.0  0.0  0.0\n",
      "2  0.0  0.0  1.0  0.0\n",
      "3  0.0  0.0  0.0  1.0\n",
      "Using the eye() function to create an identity matrix\n",
      "     0    1    2\n",
      "0  1.0  0.0  0.0\n",
      "1  0.0  1.0  0.0\n",
      "2  0.0  0.0  1.0\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import math\n",
    "\n",
    "mx = pd.DataFrame([[1,1,1], [0,1,2], [1,5,3]])\n",
    "\n",
    "print(mx)\n",
    "print(mx.values.diagonal())\n",
    "\n",
    "n = 4\n",
    "L = pd.DataFrame(np.tril(np.ones((n,n))), columns = range(n),\n",
    "                 index = range(n))\n",
    "\n",
    "U = pd.DataFrame(np.triu(np.ones((n,n))), columns = range(n),\n",
    "                 index = range(n))\n",
    "\n",
    "print(L)\n",
    "print(U)\n",
    "\n",
    "mx = pd.Series([[2,3]])\n",
    "\n",
    "mag = mx.apply(lambda x: np.linalg.norm(x))\n",
    "print(mag)\n",
    "\n",
    "unitvector = mx.apply(lambda x: x/np.linalg.norm(x))\n",
    "print(unitvector)\n",
    "\n",
    "mx = pd.Series([5,12])\n",
    "\n",
    "mag = mx.apply(lambda x: np.linalg.norm(x))\n",
    "print(mag)\n",
    "\n",
    "unitvector = mx.apply(lambda x: x/np.linalg.norm(x))\n",
    "print(unitvector)\n",
    "\n",
    "x = pd.Series([1,2,3,4,5])\n",
    "y = pd.Series([5,6,7,8,9])\n",
    "\n",
    "dimension = int(input(\"Enter the dimension of the identity matrix: \"))\n",
    "identity_matrix = pd.DataFrame(np.identity(dimension), \n",
    "                               columns = range(dimension), \n",
    "                               index = range(dimension))\n",
    "print(identity_matrix)\n",
    "\n",
    "\n",
    "print(\"Using the eye() function to create an identity matrix\")\n",
    "identity_matrix = pd.DataFrame(np.eye(3), columns = range(3), \n",
    "                               index = range(3))\n",
    "print(identity_matrix)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5ce9f229",
   "metadata": {},
   "source": [
    "### Magnitude, Unit Vectors, and Identity Matrices\n",
    "I picked the matrices section because I didn't really understand matrices to their full capacity. I'll begin with the simple parts. I started off by exploring the functions that NumPy offers for matrices. The first that I tried was the diagonal function which returns the diagonals of the matrix. I also used the \"tril\" and \"triu\" for lower and upper triangular matrices. I also used identity matrices within my code using both the np.identity() function and the np.eye() function. The hardest function that I had to understand was the unit vector function. The unit vector doesn't necessarily tell you the magnitude because it isn't supposed to but it uses magnitude within it's equation to find a purer form of the original vector. It is supposed to tell you the direction of all of the data and where the data is mostly concentrated. For instance, the magnitude of a matrix defined as [5,12] would be calculated by the formula sqrt(5^2+ 12^2). This would mean that the magnitude is 13. You would then divide each of the elements of the matrix by 13 to get the unit vector. 5/13 is 0.385 and 12/13 is 0.923. The linalg.norm function saves a lot of time in comparison to calculating the magnitude of a large matrix. The unit vector is a great way of neutralizing the magnitude to 1 so that you can compare it to other vectors. Vectors can be used for machine learning, which does make this important in my main project. I use a word vector which checks for the direction of the tweet. Unit vectors can also used in robotics, engineering, physics, and computer graphics. You use unit vectors when you are more interested in the direction rather than the length.\n",
    "\n",
    "### Pandas\n",
    ">I used the apply function to do the same thing in Pandas. This was easier than the genetic algorithm, as pandas and NumPy are closely related. This assignment showed how expansive Pandas can be when you look at it through the eyes of NumPy. NumPy is great for structured data, and Panda's takes that step to improve data manipulation so that unstructured data is easier to deal with."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "f1c42cfe",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Optimization terminated successfully.\n",
      "         Current function value: -59400.000000\n",
      "         Iterations: 3\n",
      "     con: array([], dtype=float64)\n",
      "     fun: -59400.0\n",
      " message: 'Optimization terminated successfully.'\n",
      "     nit: 3\n",
      "   slack: array([   0., 1500.])\n",
      "  status: 0\n",
      " success: True\n",
      "       x: array([   0.,    0., 2700.])\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import scipy as sp\n",
    "import pandas as pd\n",
    "\n",
    "c= pd.Series([-8, -12, -22]).values\n",
    "A= pd.DataFrame([[17, 27, 34], [12, 21, 15]]).values\n",
    "b= pd.Series([91800, 42000]).values\n",
    "\n",
    "R = (0, None)\n",
    "T = (0, None)\n",
    "M = (0, None)\n",
    "\n",
    "from scipy.optimize import linprog\n",
    "\n",
    "res = linprog(c, A_ub=A, b_ub=b, bounds=(R, T, M), method='simplex', options={\"disp\":True})\n",
    "print(res)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3b1a3120",
   "metadata": {},
   "source": [
    "### Simplex Algorithm\n",
    "I didn't understand the simplex algorithm at first but I read an analogy. Imagine a stock broker that has to pick between two kinds of stocks, Tesla, Google, or Amazon. There is a finite amount of monetary resource for you to use, and you want to maximize your profits by making the right decision. The simplex algorithm is based on the idea of improving an inital feasible solution until an optimal solution is found. The algorithm starts from a corner of the feasible region and then moves to the adjacent corner. Imagine the graph of possible choices is the feasible region and it's a map of all the decisions that Google or Tesla could make that make them profitable bargains. It's like a triangle, but you want to find the corner where you can maximize your profits which is called the objective function. Once you establish the feasible region, the region that can be used, then you look for the objective function and then slide to a different part of the triangle. This processed is repeated until you can't move no more within the objective function. \n",
    "\n",
    "This program uses the linprog function to simplify the process of finding the optimal solution. I will break down the attributes of the linprog function that are used. The objective function is c, which is basically the profit that is available. In relating this to the stock analogy, this is the extent of the stock increases. The constraints are shown by the \"A\" variable and the \"b\" variable. A represents the resources that you can use such as your savings account, the amount of margin that you can use, and your checking account. The \"b\" variable would represent your margin and your checking account. The \"R\",\"T\", \"M\" variables are non-negativity constraints which consequentially should be more than 0. the method simplex is the algorithm that is used. I could've also used the dual-simplex method but that is for another day.\n",
    "\n",
    "### Pandas\n",
    "> I converted the Panda's dataframes and serie into values. Most of these functions are useful for structured data. Using the apply method isn't necessarily helpful here, and NumPy is generally the faster option."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "22a81a19",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 0.  0.  0. ...  0.  0.  0.]\n",
      " [ 0.  0.  0. ... 50. 50. 50.]\n",
      " [ 0.  0.  0. ...  0.  0.  0.]\n",
      " [ 0.  0.  0. ...  0.  0.  0.]]\n",
      "[[  0.   0.   0. ...   0.   0.   0.]\n",
      " [  0.   0.   0. ...  50.  50.  50.]\n",
      " [  0.   0.   0. ... 140. 140. 140.]\n",
      " [  0.   0.   0. ...   0.   0.   0.]]\n",
      "[[  0.   0.   0. ...   0.   0.   0.]\n",
      " [  0.   0.   0. ...  50.  50.  50.]\n",
      " [  0.   0.   0. ... 140. 140. 140.]\n",
      " [  0.   0.   0. ... 390. 390. 390.]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "390.0"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "\n",
    "def knapsack(items, capacity):\n",
    "    n = len(items)\n",
    "    weight, value, num = zip(*items) # unpack items into separate lists for weight, value, and num\n",
    "    weight = pd.Series(weight).values\n",
    "    value = pd.Series(value).values\n",
    "    dp = np.zeros((n+1, capacity+1))\n",
    "    for i in range(1, n+1):\n",
    "        dp[i, weight[i-1]:] = np.maximum(dp[i-1, weight[i-1]:], dp[i-1, :-weight[i-1]]+value[i-1])\n",
    "        print(dp)\n",
    "    return dp[n, capacity]\n",
    "\n",
    "val = pd.DataFrame([(10, 50, 30), (70, 90, 180), (70, 250, 100)])\n",
    "knapsack(val.values, 500)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "31001b09",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "3\n",
      "   0    1    2    3    4    5    6    7    8    9    ...  491  492  493  494  \\\n",
      "0    0    0    0    0    0    0    0    0    0    0  ...    0    0    0    0   \n",
      "1    0    0    0    0    0    0    0    0    0    0  ...   50   50   50   50   \n",
      "2    0    0    0    0    0    0    0    0    0    0  ...    0    0    0    0   \n",
      "3    0    0    0    0    0    0    0    0    0    0  ...    0    0    0    0   \n",
      "\n",
      "   495  496  497  498  499  500  \n",
      "0    0    0    0    0    0    0  \n",
      "1   50   50   50   50   50   50  \n",
      "2    0    0    0    0    0    0  \n",
      "3    0    0    0    0    0    0  \n",
      "\n",
      "[4 rows x 501 columns]\n",
      "   0    1    2    3    4    5    6    7    8    9    ...  491  492  493  494  \\\n",
      "0    0    0    0    0    0    0    0    0    0    0  ...    0    0    0    0   \n",
      "1    0    0    0    0    0    0    0    0    0    0  ...   50   50   50   50   \n",
      "2    0    0    0    0    0    0    0    0    0    0  ...  140  140  140  140   \n",
      "3    0    0    0    0    0    0    0    0    0    0  ...    0    0    0    0   \n",
      "\n",
      "   495  496  497  498  499  500  \n",
      "0    0    0    0    0    0    0  \n",
      "1   50   50   50   50   50   50  \n",
      "2  140  140  140  140  140  140  \n",
      "3    0    0    0    0    0    0  \n",
      "\n",
      "[4 rows x 501 columns]\n",
      "   0    1    2    3    4    5    6    7    8    9    ...  491  492  493  494  \\\n",
      "0    0    0    0    0    0    0    0    0    0    0  ...    0    0    0    0   \n",
      "1    0    0    0    0    0    0    0    0    0    0  ...   50   50   50   50   \n",
      "2    0    0    0    0    0    0    0    0    0    0  ...  140  140  140  140   \n",
      "3    0    0    0    0    0    0    0    0    0    0  ...  390  390  390  390   \n",
      "\n",
      "   495  496  497  498  499  500  \n",
      "0    0    0    0    0    0    0  \n",
      "1   50   50   50   50   50   50  \n",
      "2  140  140  140  140  140  140  \n",
      "3  390  390  390  390  390  390  \n",
      "\n",
      "[4 rows x 501 columns]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "390"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import pandas as pd\n",
    "\n",
    "def knapsack(items, capacity):\n",
    "    n = len(items)\n",
    "    weight, value, num = zip(*items) # unpack items into separate lists for weight, value, and num\n",
    "    weight = pd.Series(weight)\n",
    "    value = pd.Series(value)\n",
    "    dp = pd.DataFrame(0, index=range(n+1), columns=range(capacity+1))\n",
    "    for i in range(1, n+1):\n",
    "        padded_slice = np.pad(dp.iloc[i-1, :-weight[i-1]]+value[i-1], \n",
    "                              (weight[i-1], 0), 'constant', \n",
    "                              constant_values=(0))\n",
    "        dp.iloc[i, :] = np.maximum(dp.iloc[i-1, :], padded_slice)\n",
    "        print(dp)\n",
    "    return dp.loc[n, capacity]\n",
    "\n",
    "val = pd.DataFrame([(10, 50, 30), (70, 90, 180), (70, 250, 100)])\n",
    "knapsack(val.values, 500)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7389734c",
   "metadata": {},
   "source": [
    "### KnapSack Problem with Dynamic Programming\n",
    "\n",
    "The Knapsack Problem is complicated when seen from a literal perspective, so I will illustrate what it means by an example. Imagine a thief breaks into a home with the intent to steal and they carry a knapsack. There is a certain amount of items in the home with their own weights and values. Jewelry may have higher value than tables, while tables are heavier but not as valuable. There is no compromise where the robber can split either or to fill his entire knapsack. \n",
    "\n",
    "I used dynamic programming for this example. Dynamic programming divides the problem to be solved into subproblems. The subproblems are further divided into smaller subproblems until the subproblem can be solved easily.\n",
    "\n",
    "The rows correspond to 0 to n, and the columns of the table correspond to the weight limit from 0 to W. These are the two variable integers of the knapsack function. In this particular code, there are 5 rows and 65 columns.\n",
    "\n",
    "There is a table variable that is created via the list comprehension method which basically means the creation of lists based on existing iterables. Once the columns and rows are established, we iterate through them with nested for loops. This defines the table variable because it was previously filled with only 0's.\n",
    "\n",
    "After the nested for loops are created, the following code that performs an if statement to see if the iterated elements are equal to zero also sets the 0th row and column to 0.\n",
    "\n",
    "There is an else if statement that is performed to check the weight of the current row element and see if it is less than or equal to the current column element.\n",
    "\n",
    "The next section that involves the assignment of the table elements, and it is responsible for finding the maximum value of the current row element in the iteration.\n",
    "\n",
    "There is an else statement to couplement the if statement that checks when the current row element in the iteration is greater than the column element or what we can call the permissible limit.\n",
    "\n",
    "When these iterations are done, the last cell of the table is returned as the answer to this function.\n",
    "\n",
    "This type of problem is complex in the world of computers. There is another approach known as the greedy approach and it is used to calculate the ratio value/weight for each item and sort the item based on the calculated ratio. You then have to take the item with the highest ratio, and add it to the knapsack until you can't add the item as a whole. In the end, you add the following item as much as possible.\n",
    "\n",
    "### Pandas\n",
    ">This code is changed to match the Pandas library. I used np.pad to fill the dataframe so that the sizes were comparable for the np.maximum function performed on the padded slice which contains the actual values, and the previous values held in the dp.iloc[i-1, :] variable."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8778ef38",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.13"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
